package io.logic;

import com.google.auto.service.AutoService;
import com.google.common.base.CaseFormat;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeName;
import io.logic.Logic.Ignore;
import io.logic.Logic.Include;
import io.logic.Logic.Mixin;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * An annotation processor for {@link Logic}.
 * <p>
 * {@link LogicProcessor} generates both the <a href="https://github.com/iancaffey/logic">logic</a> runtime on request
 * and any user-defined logic models found with the {@link Logic} or {@link Include} annotations.
 * <p>
 * Types being "logically modeled" will have an entire hierarchy of {@link Predicate} generated to create an API for
 * logic programming.
 *
 * @author Ian Caffey
 * @since 1.0
 */
@AutoService(Processor.class)
@SupportedOptions(LogicProcessor.INCLUDE_RUNTIME_KEY)
@SupportedAnnotationTypes({"io.logic.Logic", "io.logic.Logic.Include"})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class LogicProcessor extends AbstractProcessor {
    static final String INCLUDE_RUNTIME_KEY = "logic.include.runtime";
    private static final Map<Visibility, Modifier> VISIBILITY_MODIFIERS = ImmutableMap.of(
            Visibility.PUBLIC, Modifier.PUBLIC,
            Visibility.PRIVATE, Modifier.PRIVATE,
            Visibility.PROTECTED, Modifier.PROTECTED
    );
    private static final Map<TypeKind, Class<?>> PRIMITIVE_TYPES = ImmutableMap.<TypeKind, Class<?>>builder()
            .put(TypeKind.BOOLEAN, boolean.class)
            .put(TypeKind.BYTE, byte.class)
            .put(TypeKind.SHORT, short.class)
            .put(TypeKind.INT, int.class)
            .put(TypeKind.LONG, long.class)
            .put(TypeKind.CHAR, char.class)
            .put(TypeKind.FLOAT, float.class)
            .put(TypeKind.DOUBLE, double.class)
            .build();

    /**
     * Performs all {@link Logic} modeling for classes made available to the annotation processor.
     * <p>
     * If the option {@link LogicProcessor#INCLUDE_RUNTIME_KEY} is found and set to {@code true}, the logic runtime is
     * generated by {@link NativeLogic#getPredicates()} and written as source files.
     * <p>
     * Also, all elements in the {@link RoundEnvironment} are searched for elements annotated with {@link Logic} or
     * {@link Include} and are modeled as {@link PredicateDefinition} using {@link LogicProcessor#findLogic(RoundEnvironment)}
     * and written as source files.
     *
     * @param annotations the annotation types requested to be processed
     * @param roundEnv    environment for information about the current and prior round
     * @return {@code false} to never claim the annotation types to be processed
     */
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (roundEnv.processingOver() || annotations.isEmpty()) {
            return false;
        }
        if (Boolean.parseBoolean(processingEnv.getOptions().get(INCLUDE_RUNTIME_KEY))) {
            LogicGenerator.generate(NativeLogic.getPredicates()).forEach(this::write);
        }
        LogicGenerator.generate(findLogic(roundEnv)).forEach(this::write);
        return false;
    }

    /**
     * Searches through all elements in the {@link RoundEnvironment} for elements annotated with {@link Logic} or
     * {@link Include} and creates {@link PredicateDefinition} for each found element.
     *
     * @param roundEnv the round environment used to find logic models
     * @return a set of {@link PredicateDefinition} which represents every type being modeled
     */
    @SuppressWarnings("unchecked")
    private Set<PredicateDefinition> findLogic(RoundEnvironment roundEnv) {
        ImmutableSet.Builder<DeclaredTypeLogic> declaredTypeLogicBuilder = ImmutableSet.builder();
        ImmutableSet.Builder<PrimitiveTypeLogic> primitiveTypeLogicBuilder = ImmutableSet.builder();
        //Collect all explicit @Logic declarations from annotated classes
        roundEnv.getElementsAnnotatedWith(Logic.class).forEach(element -> {
            if (!(element instanceof TypeElement)) {
                throw new RuntimeException("Found a @Logic annotation on a non-type element.");
            }
            declaredTypeLogicBuilder.add(DeclaredTypeLogic.of(element, (TypeElement) element, element.getAnnotation(Logic.class)));
        });
        //Collect all implicit @Logic declarations brought in by @Logic.Include
        TypeMirror includeTypeMirror = processingEnv.getElementUtils().getTypeElement(Include.class.getCanonicalName()).asType();
        roundEnv.getElementsAnnotatedWith(Include.class).forEach(element -> {
            Logic logic = element.getAnnotation(Include.class).logic();
            //You cannot directly reflect the Class<?>[] from Logic.Include within an annotation processor
            for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
                if (!processingEnv.getTypeUtils().isSameType(includeTypeMirror, mirror.getAnnotationType())) {
                    continue;
                }
                processingEnv.getElementUtils().getElementValuesWithDefaults(mirror).forEach((key, value) -> {
                    if ("value".equals(key.getSimpleName().toString())) {
                        for (AnnotationValue includedTypeValue : ((List<? extends AnnotationValue>) value.getValue())) {
                            TypeMirror includedType = (TypeMirror) includedTypeValue.getValue();
                            if (includedType instanceof PrimitiveType) {
                                primitiveTypeLogicBuilder.add(PrimitiveTypeLogic.of(element, PRIMITIVE_TYPES.get(includedType.getKind()), logic));
                            } else if (includedType instanceof DeclaredType) {
                                Element includedTypeElement = ((DeclaredType) includedType).asElement();
                                if (!(includedTypeElement instanceof TypeElement)) {
                                    throw new RuntimeException("Found a @Logic.Include annotation on a non-type element.");
                                }
                                declaredTypeLogicBuilder.add(DeclaredTypeLogic.of(element, (TypeElement) includedTypeElement, logic));
                            } else {
                                throw new RuntimeException("@Logic.Include only supports class, interface, or primitive types: " + includedType);
                            }
                        }
                    }
                });
            }
        });
        //Convert all DeclaredTypeLogic -> DeclaredTypeDefinition
        Stream<PredicateDefinition> declaredTypes = declaredTypeLogicBuilder.build().stream().map(typeLogic -> {
            Element source = typeLogic.getSource();
            TypeElement type = typeLogic.getType();
            Logic logic = typeLogic.getLogic();
            String namespaceOverride = logic.namespace();
            String namespace = namespaceOverride.isEmpty() ?
                    processingEnv.getElementUtils().getPackageOf(source).getQualifiedName().toString() :
                    namespaceOverride;
            PredicateDefinition.Builder builder = PredicateDefinition.builder()
                    .setPredicateName(ClassName.get(namespace, type.getSimpleName() + "Predicate"))
                    .setTypeName(ClassName.get(type))
                    .setGsonEnabled(logic.gson())
                    .setVisitorEnabled(logic.visitor());
            List<? extends Element> enclosedElements = type.getEnclosedElements();
            //Add all detected fields to the PredicateDefinition
            Set<Pattern> fieldPatterns = Arrays.stream(logic.fields()).map(this::toPattern).collect(ImmutableSet.toImmutableSet());
            enclosedElements.stream()
                    .filter(element -> !element.getModifiers().contains(Modifier.STATIC))
                    .filter(element -> element.getAnnotation(Ignore.class) == null) //Explicitly ignored element
                    .filter(element -> element.getKind() == ElementKind.FIELD)
                    .filter(element -> element instanceof VariableElement)
                    .filter(element -> Arrays.stream(logic.fieldVisibility()).anyMatch(visibility -> withinAccess(visibility, element.getModifiers())))
                    .forEach(element -> {
                        for (Pattern pattern : fieldPatterns) {
                            Matcher matcher = pattern.matcher(element.getSimpleName());
                            if (matcher.matches()) {
                                builder.addMember(FieldDefinitionAdapter.convert(matcher.group(1), (VariableElement) element));
                            }
                        }
                    });
            //Add all detected methods to the PredicateDefinition
            Set<Pattern> methodPatterns = Arrays.stream(logic.methods()).map(this::toPattern).collect(ImmutableSet.toImmutableSet());
            enclosedElements.stream()
                    .filter(element -> !element.getModifiers().contains(Modifier.STATIC))
                    .filter(element -> element.getAnnotation(Ignore.class) == null) //Explicitly ignored element
                    .filter(element -> element.getKind() == ElementKind.METHOD)
                    .filter(element -> (element instanceof ExecutableElement) && ((ExecutableElement) element).getParameters().isEmpty())
                    .filter(element -> Arrays.stream(logic.methodVisibility()).anyMatch(visibility -> withinAccess(visibility, element.getModifiers())))
                    .forEach(element -> {
                        for (Pattern pattern : methodPatterns) {
                            Matcher matcher = pattern.matcher(element.getSimpleName());
                            if (matcher.matches()) {
                                builder.addMember(MethodDefinitionAdapter.convert(matcher.group(1), (ExecutableElement) element));
                            }
                        }
                    });
            //Add all @Logic.Mixin to the PredicateDefinition
            for (Mixin mixin : logic.mixins()) {
                builder.addMember(MixinDefinitionAdapter.convert(mixin));
            }
            return builder.build();
        });
        //Convert all PrimitiveTypeLogic -> PrimitiveTypeDefinition
        Stream<PredicateDefinition> primitiveTypes = primitiveTypeLogicBuilder.build().stream().map(typeLogic -> {
            Element source = typeLogic.getSource();
            Class<?> type = typeLogic.getType();
            Logic logic = typeLogic.getLogic();
            String typeName = type.getName();
            String namespace = processingEnv.getElementUtils().getPackageOf(source).getQualifiedName().toString();
            PredicateDefinition.Builder builder = PredicateDefinition.builder()
                    .setPredicateName(ClassName.get(namespace, CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, typeName) + "Predicate"))
                    .setTypeName(TypeName.get(type));
            //Add all @Logic.Mixin to the PredicateDefinition (primitive type definition only have mixins as members)
            for (Mixin mixin : logic.mixins()) {
                builder.addMember(MixinDefinitionAdapter.convert(mixin));
            }
            return builder.build();
        });
        return Stream.concat(declaredTypes, primitiveTypes).collect(ImmutableSet.toImmutableSet());
    }

    /**
     * Tests whether the specified set of {@link Modifier} are within the scope of the member {@link Visibility}.
     * <p>
     * Access level {@link Modifier} (e.g. {@link Modifier#PRIVATE}, {@link Modifier#PUBLIC}, {@link Modifier#PRIVATE},
     * {@link Modifier#PROTECTED})
     * are mapped to the corresponding {@link Visibility}, if it exists. If no access level modifiers are present,
     * {@link Visibility#PACKAGE} is inferred and tested against the specified visibility.
     *
     * @param visibility the allowed access level
     * @param modifiers  the set of modifiers which can contain access level modifiers
     * @return {@code true} if the specified visibility corresponds to the relevant access modifier inferred from the provided modifiers
     */
    private boolean withinAccess(Visibility visibility, Set<Modifier> modifiers) {
        switch (visibility) {
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
                return modifiers.contains(VISIBILITY_MODIFIERS.get(visibility));
            case PACKAGE:
                //package-local elements will have none of the explicit access-level modifiers
                return VISIBILITY_MODIFIERS.values().stream().noneMatch(modifiers::contains);
            default:
                throw new UnsupportedOperationException("Unsupported visibility level " + visibility);
        }
    }

    /**
     * Converts a {@link Logic} member matcher expression into a {@link Pattern}. Every {@code *} is replaced by a
     * non-empty capturing group {@code (.+)}.
     *
     * @param expression the logic member matcher expression
     * @return a {@link Pattern} that represents the logic member matcher expression
     */
    private Pattern toPattern(String expression) {
        return Pattern.compile(expression.replace("*", "(.+)"));
    }

    /**
     * Writes the {@link JavaFile} out to the {@link ProcessingEnvironment#getFiler()}.
     *
     * @param file the file to write
     * @throws IllegalArgumentException if an exception occurs when writing the file
     */
    private void write(JavaFile file) {
        try {
            file.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            throw new IllegalArgumentException("Failed to write Logic file.", e);
        }
    }
}
